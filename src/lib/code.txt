import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.io.TempDir;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.nio.file.Path;
import java.util.Properties;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class PropertyHandlerTest {

    @TempDir
    Path tempDir;
    
    private MockedStatic<LogManager> logManagerMock;
    private Logger mockLogger;
    
    @BeforeEach
    void setUp() {
        // Reset singleton instance before each test
        resetSingleton();
        
        // Mock logger
        mockLogger = mock(Logger.class);
        logManagerMock = mockStatic(LogManager.class);
        logManagerMock.when(() -> LogManager.getLogger(PropertyHandler.class))
                     .thenReturn(mockLogger);
    }
    
    @AfterEach
    void tearDown() {
        logManagerMock.close();
        resetSingleton();
        // Clear system properties
        System.clearProperty("Config_filePath");
    }
    
    private void resetSingleton() {
        try {
            Field instanceField = PropertyHandler.class.getDeclaredField("instance");
            instanceField.setAccessible(true);
            instanceField.set(null, null);
        } catch (Exception e) {
            // Ignore - field might not exist yet
        }
    }
    
    @Test
    @DisplayName("Test singleton pattern - same instance returned")
    void testSingletonPattern() {
        PropertyHandler instance1 = PropertyHandler.getInstance();
        PropertyHandler instance2 = PropertyHandler.getInstance();
        
        assertSame(instance1, instance2, "getInstance() should return the same instance");
        assertNotNull(instance1, "Instance should not be null");
    }
    
    @Test
    @DisplayName("Test constructor with valid properties file in custom path")
    void testConstructorWithCustomConfigPath() throws IOException {
        // Create a temporary properties file
        File propertiesFile = tempDir.resolve("Database_Query.properties").toFile();
        try (FileWriter writer = new FileWriter(propertiesFile)) {
            writer.write("test.property=test.value\n");
            writer.write("database.url=jdbc:mysql://localhost:3306/test\n");
        }
        
        // Set system property
        System.setProperty("Config_filePath", tempDir.toString());
        
        PropertyHandler instance = PropertyHandler.getInstance();
        
        assertNotNull(instance);
        verify(mockLogger, never()).error(anyString());
        verify(mockLogger, never()).error(anyString(), any(Exception.class));
    }
    
    @Test
    @DisplayName("Test constructor with valid properties file in default path")
    void testConstructorWithDefaultPath() throws IOException {
        // Create properties file in current directory
        File propertiesFile = new File("Database_Query.properties");
        try (FileWriter writer = new FileWriter(propertiesFile)) {
            writer.write("test.property=test.value\n");
        }
        
        try {
            PropertyHandler instance = PropertyHandler.getInstance();
            
            assertNotNull(instance);
            verify(mockLogger, never()).error(anyString());
            verify(mockLogger, never()).error(anyString(), any(Exception.class));
        } finally {
            // Clean up
            propertiesFile.delete();
        }
    }
    
    @Test
    @DisplayName("Test constructor with FileNotFoundException")
    void testConstructorWithFileNotFoundException() {
        // Don't create any properties file
        System.setProperty("Config_filePath", "/nonexistent/path");
        
        PropertyHandler instance = PropertyHandler.getInstance();
        
        assertNotNull(instance);
        verify(mockLogger).error("FileNotFoundException thrown during Send Mail Notification ");
        verify(mockLogger).error(eq("ERROR:"), any(Exception.class));
    }
    
    @Test
    @DisplayName("Test constructor with FileNotFoundException in default path")
    void testConstructorWithFileNotFoundInDefaultPath() {
        // Ensure no properties file exists in current directory
        File propertiesFile = new File("Database_Query.properties");
        if (propertiesFile.exists()) {
            propertiesFile.delete();
        }
        
        PropertyHandler instance = PropertyHandler.getInstance();
        
        assertNotNull(instance);
        verify(mockLogger).error("FileNotFoundException thrown during Send Mail Notification ");
        verify(mockLogger).error(eq("ERROR:"), any(Exception.class));
    }
    
    @Test
    @DisplayName("Test constructor with malformed properties file")
    void testConstructorWithMalformedPropertiesFile() throws IOException {
        // Create a malformed properties file
        File propertiesFile = tempDir.resolve("Database_Query.properties").toFile();
        try (FileWriter writer = new FileWriter(propertiesFile)) {
            writer.write("malformed content that cannot be parsed as properties\n");
            writer.write("=invalid=line=\n");
        }
        
        System.setProperty("Config_filePath", tempDir.toString());
        
        PropertyHandler instance = PropertyHandler.getInstance();
        
        assertNotNull(instance);
        // Should not throw exception but may log errors depending on Properties.load() behavior
    }
    
    @Test
    @DisplayName("Test constructor handles null Config_filePath")
    void testConstructorWithNullConfigPath() {
        System.clearProperty("Config_filePath");
        
        PropertyHandler instance = PropertyHandler.getInstance();
        
        assertNotNull(instance);
        // Should try to load from default path
    }
    
    @Test
    @DisplayName("Test private constructor accessibility")
    void testPrivateConstructor() throws Exception {
        Constructor<PropertyHandler> constructor = PropertyHandler.class.getDeclaredConstructor();
        assertTrue(java.lang.reflect.Modifier.isPrivate(constructor.getModifiers()));
        
        constructor.setAccessible(true);
        PropertyHandler instance = constructor.newInstance();
        assertNotNull(instance);
    }
    
    @Test
    @DisplayName("Test getInstance thread safety")
    void testGetInstanceThreadSafety() throws InterruptedException {
        final PropertyHandler[] instances = new PropertyHandler[10];
        Thread[] threads = new Thread[10];
        
        for (int i = 0; i < 10; i++) {
            final int index = i;
            threads[i] = new Thread(() -> {
                instances[index] = PropertyHandler.getInstance();
            });
        }
        
        for (Thread thread : threads) {
            thread.start();
        }
        
        for (Thread thread : threads) {
            thread.join();
        }
        
        // All instances should be the same
        PropertyHandler firstInstance = instances[0];
        for (PropertyHandler instance : instances) {
            assertSame(firstInstance, instance);
        }
    }
    
    @Test
    @DisplayName("Test logger initialization")
    void testLoggerInitialization() {
        PropertyHandler.getInstance();
        
        logManagerMock.verify(() -> LogManager.getLogger(PropertyHandler.class));
    }
    
    @Test
    @DisplayName("Test config Properties initialization")
    void testConfigPropertiesInitialization() throws Exception {
        PropertyHandler instance = PropertyHandler.getInstance();
        
        Field configField = PropertyHandler.class.getDeclaredField("config");
        configField.setAccessible(true);
        Properties config = (Properties) configField.get(instance);
        
        assertNotNull(config);
    }
    
    @Test
    @DisplayName("Test password fields initialization")
    void testPasswordFieldsInitialization() throws Exception {
        PropertyHandler instance = PropertyHandler.getInstance();
        
        // Test that password fields exist and are initialized
        Field strPassRCMField = PropertyHandler.class.getDeclaredField("strPassRCM");
        Field strPassGFTSField = PropertyHandler.class.getDeclaredField("strPassGFTS");
        Field strPassIMPLField = PropertyHandler.class.getDeclaredField("strPassIMPL");
        Field strPassWSField = PropertyHandler.class.getDeclaredField("strPassWS");
        
        assertNotNull(strPassRCMField);
        assertNotNull(strPassGFTSField);
        assertNotNull(strPassIMPLField);
        assertNotNull(strPassWSField);
    }
    
    @Test
    @DisplayName("Test properties loading with actual content")
    void testPropertiesLoadingWithContent() throws Exception {
        // Create properties file with specific content
        File propertiesFile = tempDir.resolve("Database_Query.properties").toFile();
        try (FileWriter writer = new FileWriter(propertiesFile)) {
            writer.write("test.key=test.value\n");
            writer.write("database.url=jdbc:mysql://localhost:3306/test\n");
            writer.write("username=testuser\n");
        }
        
        System.setProperty("Config_filePath", tempDir.toString());
        
        PropertyHandler instance = PropertyHandler.getInstance();
        
        // Access the config field to verify properties were loaded
        Field configField = PropertyHandler.class.getDeclaredField("config");
        configField.setAccessible(true);
        Properties config = (Properties) configField.get(instance);
        
        assertEquals("test.value", config.getProperty("test.key"));
        assertEquals("jdbc:mysql://localhost:3306/test", config.getProperty("database.url"));
        assertEquals("testuser", config.getProperty("username"));
    }
}
